package internal

import (
	"fmt"
	"net/http"
)

func Server(addr string) error {
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte(`
			<html>
				<head>
					<title>regexp2go demo</title>
				</head>
				<body>
					<h1>regexp2go</h1>
					<p>
						Compile <a href="https://golang.org/pkg/regexp/syntax/">Go regular expressions</a> to Go code.
					</p>
					<form method=post action="/generate">
						<input type=text name=regex placeholder="Regexp">
						<input type=submit>
					</form>
					<p>
						Warning: regexp2go is alpha quality.
						The code generated by regexp2go should currently only be used for demonstration purposes.
						See <a href="https://github.com/CAFxX/regexp2go">github.com/CAFxX/regexp2go</a> for details.
					</p>
				</body>
			</html>
		`))
	})
	http.HandleFunc("/generate", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			w.WriteHeader(http.StatusMethodNotAllowed)
			fmt.Fprintf(w, "method not allowed: %s\n", r.Method)
			return
		}

		if err := r.ParseForm(); err != nil {
			w.WriteHeader(http.StatusBadRequest)
			fmt.Fprintf(w, "bad request\n")
			return
		}

		regex := r.Form.Get("regex")
		if regex == "" {
			w.WriteHeader(http.StatusUnprocessableEntity)
			fmt.Fprintf(w, "invalid request: empty regexp\n")
			return
		}
		if len(regex) > 2000 {
			w.WriteHeader(http.StatusUnprocessableEntity)
			fmt.Fprintf(w, "invalid request: regexp is too long for demo\n")
			return
		}

		res, err := Generate(regex, "regexp2go_demo", "Match", 212)
		if err != nil {
			w.WriteHeader(http.StatusUnprocessableEntity)
			fmt.Fprintf(w, "generate: %v\n", err)
			return
		}

		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.Write(res)
	})
	return http.ListenAndServe(addr, nil)
}
