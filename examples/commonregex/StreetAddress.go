// File generated by regexp2go. DO NOT EDIT.
// regexp2go -flags=212 -pkg="commonregex" -fn="StreetAddress" -pool=true "\\d{1,4} [\\w\\s]{1,20}(?:street|st|avenue|ave|road|rd|highway|hwy|square|sq|trail|trl|drive|dr|court|ct|park|parkway|pkwy|circle|cir|boulevard|blvd)\\W?"

package commonregex

import "regexp/syntax"
import "unicode/utf8"
import "strings"
import "reflect"
import "unsafe"
import "runtime"
import "github.com/CAFxX/bytespool"

const StreetAddressRegexp = "\\d{1,4} [\\w\\s]{1,20}(?:street|st|avenue|ave|road|rd|highway|hwy|square|sq|trail|trl|drive|dr|court|ct|park|parkway|pkwy|circle|cir|boulevard|blvd)\\W?"

var (
	_ = syntax.IsWordChar
	_ = strings.Index
)

type modeTypeStreetAddress uint8

const (
	modeMatchStreetAddress modeTypeStreetAddress = iota
	modeFirstStreetAddress
	modeLongestStreetAddress
)

// StreetAddress implements the regular expression
// \d{1,4} [\w\s]{1,20}(?:street|st|avenue|ave|road|rd|highway|hwy|square|sq|trail|trl|drive|dr|court|ct|park|parkway|pkwy|circle|cir|boulevard|blvd)\W?
// with flags 212.
type StreetAddress struct{}
type stateStreetAddress struct {
	c   [2]int
	i   int
	pc  int
	cnt int
}

// FindString returns the first leftmost match.
func (e StreetAddress) FindString(r string) (matches [1]string, pos int, ok bool) {
	var bt [45]stateStreetAddress // static storage for backtracking state
	matches, pos, ok = e.doString(r, modeFirstStreetAddress, bt[:0])
	return
}

// FindLongestString returns the leftmost-longest match.
func (e StreetAddress) FindLongestString(r string) (matches [1]string, pos int, ok bool) {
	var bt [45]stateStreetAddress // static storage for backtracking state
	matches, pos, ok = e.doString(r, modeLongestStreetAddress, bt[:0])
	return
}

// Find returns the first leftmost match.
func (e StreetAddress) Find(s []byte) (matches [1][]byte, pos int, ok bool) {
	var bt [45]stateStreetAddress // static storage for backtracking state
	matches, pos, ok = e.doByteSlice(s, modeFirstStreetAddress, bt[:0])
	return
}

// FindLongest returns the leftmost-longest match.
func (e StreetAddress) FindLongest(s []byte) (matches [1][]byte, pos int, ok bool) {
	var bt [45]stateStreetAddress // static storage for backtracking state
	matches, pos, ok = e.doByteSlice(s, modeLongestStreetAddress, bt[:0])
	return
}

func (e StreetAddress) doByteSlice(s []byte, m modeTypeStreetAddress, bt []stateStreetAddress) (matches [1][]byte, pos int, ok bool) {
	var r string
	rhdr := (*reflect.StringHeader)(unsafe.Pointer(&r))
	rhdr.Data = uintptr(unsafe.Pointer(&s[0]))
	rhdr.Len = len(s)

	var pmatches [1 * 2]int
	pmatches, ok = e.do(r, m, bt)
	pos = pmatches[0]

	for i := range matches {
		if pmatches[i*2] < 0 {
			continue
		}
		matches[i] = s[pmatches[i*2]:pmatches[i*2+1]:pmatches[i*2+1]]
	}

	runtime.KeepAlive(s)
	return
}

func (e StreetAddress) doString(s string, m modeTypeStreetAddress, bt []stateStreetAddress) (matches [1]string, pos int, ok bool) {
	var pmatches [1 * 2]int
	pmatches, ok = e.do(s, m, bt)
	pos = pmatches[0]

	for i := range matches {
		if pmatches[i*2] < 0 {
			continue
		}
		matches[i] = s[pmatches[i*2]:pmatches[i*2+1]]
	}

	return
}

func (e StreetAddress) do(r string, m modeTypeStreetAddress, bt []stateStreetAddress) ([2]int, bool) {
	si := 0 // starting byte index

	ppi := bytespool.GetBytesSlicePtr(((len(r)+1)*45 + 7) / 8)
	defer func() {
		pi := *ppi
		for i := range pi {
			pi[i] = 0
		}
		bytespool.PutBytesSlicePtr(ppi)
	}()
	pi := *ppi
	_ = pi

restart:
	bt = bt[:0]         // fast reset dynamic backtracking state
	c := [2]int{-1, -1} // captures
	var bc [2]int       // captures for the longest match so far
	matched := false    // succesful match flag
	i := si             // current byte index
	c[0] = i            // start of match
	goto inst1          // initial instruction

	goto unreachable
	goto inst3
inst3: // rune "09" -> 5
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cr >= 48 && cr <= 57 {
			i += sz
			goto inst5
		}
	}
	goto inst3_fail
	goto unreachable
	goto inst3_fail
inst3_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 6:
			goto inst6_alt
		}
	}
	goto fail

	goto unreachable
	goto inst5
inst5: // alt -> 4, 8
	{
		idx := i*45 + 0
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 5, 0})
	goto inst4
inst5_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst8
	}
	goto unreachable

	goto unreachable
	goto inst4
inst4: // rune "09" -> 8
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cr >= 48 && cr <= 57 {
			i += sz
			goto inst8
		}
	}
	goto inst4_fail
	goto unreachable
	goto inst4_fail
inst4_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 5:
			goto inst5_alt
		}
	}
	goto fail

	goto unreachable
	goto inst8
inst8: // string " " -> 9
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 1 && rs[:1] == " " {
			i += 1
			goto inst9
		}
	}
	goto inst8_fail
	goto unreachable
	goto inst8_fail
inst8_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 5:
			goto inst5_alt
		case 6:
			goto inst6_alt
		case 7:
			goto inst7_alt
		}
	}
	goto fail

	goto unreachable
	goto inst6
inst6: // alt -> 3, 8
	{
		idx := i*45 + 1
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 6, 0})
	goto inst3
inst6_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst8
	}
	goto unreachable

	goto unreachable
	goto inst2
inst2: // rune "09" -> 6
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cr >= 48 && cr <= 57 {
			i += sz
			goto inst6
		}
	}
	goto inst2_fail
	goto unreachable
	goto inst2_fail
inst2_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 7:
			goto inst7_alt
		}
	}
	goto fail

	goto unreachable
	goto inst7
inst7: // alt -> 2, 8
	{
		idx := i*45 + 2
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 7, 0})
	goto inst2
inst7_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst8
	}
	goto unreachable

	goto unreachable
	goto inst1
inst1: // rune "09" -> 7
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cr >= 48 && cr <= 57 {
			i += sz
			goto inst7
		}
	}
	goto inst1_fail
	goto unreachable
	goto inst1_fail
inst1_fail:
	goto fail

	goto unreachable
	goto inst9
inst9: // rune "\t\n\f\r  09AZ__az" -> 47
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x006\x00\x00\x01\x00\xff\x03\xfe\xff\xff\x87\xfe\xff\xff\a"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst47
			}
			goto inst9_fail
		}
	}
	goto inst9_fail
	goto unreachable
	goto inst9_fail
inst9_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 5:
			goto inst5_alt
		case 6:
			goto inst6_alt
		case 7:
			goto inst7_alt
		}
	}
	goto fail

	goto unreachable
	goto inst17
inst17: // rune "\t\n\f\r  09AZ__az" -> 39
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x006\x00\x00\x01\x00\xff\x03\xfe\xff\xff\x87\xfe\xff\xff\a"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst39
			}
			goto inst17_fail
		}
	}
	goto inst17_fail
	goto unreachable
	goto inst17_fail
inst17_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 40:
			goto inst40_alt
		}
	}
	goto fail

	goto unreachable
	goto inst40
inst40: // alt -> 17, 152
	{
		idx := i*45 + 3
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 40, 0})
	goto inst17
inst40_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst152
	}
	goto unreachable

	goto unreachable
	goto inst20
inst20: // rune "\t\n\f\r  09AZ__az" -> 36
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x006\x00\x00\x01\x00\xff\x03\xfe\xff\xff\x87\xfe\xff\xff\a"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst36
			}
			goto inst20_fail
		}
	}
	goto inst20_fail
	goto unreachable
	goto inst20_fail
inst20_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 37:
			goto inst37_alt
		}
	}
	goto fail

	goto unreachable
	goto inst36
inst36: // alt -> 21, 152
	{
		idx := i*45 + 4
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 36, 0})
	goto inst21
inst36_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst152
	}
	goto unreachable

	goto unreachable
	goto inst21
inst21: // rune "\t\n\f\r  09AZ__az" -> 35
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x006\x00\x00\x01\x00\xff\x03\xfe\xff\xff\x87\xfe\xff\xff\a"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst35
			}
			goto inst21_fail
		}
	}
	goto inst21_fail
	goto unreachable
	goto inst21_fail
inst21_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 36:
			goto inst36_alt
		}
	}
	goto fail

	goto unreachable
	goto inst35
inst35: // alt -> 22, 152
	{
		idx := i*45 + 5
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 35, 0})
	goto inst22
inst35_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst152
	}
	goto unreachable

	goto unreachable
	goto inst22
inst22: // rune "\t\n\f\r  09AZ__az" -> 34
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x006\x00\x00\x01\x00\xff\x03\xfe\xff\xff\x87\xfe\xff\xff\a"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst34
			}
			goto inst22_fail
		}
	}
	goto inst22_fail
	goto unreachable
	goto inst22_fail
inst22_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 35:
			goto inst35_alt
		}
	}
	goto fail

	goto unreachable
	goto inst37
inst37: // alt -> 20, 152
	{
		idx := i*45 + 6
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 37, 0})
	goto inst20
inst37_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst152
	}
	goto unreachable

	goto unreachable
	goto inst19
inst19: // rune "\t\n\f\r  09AZ__az" -> 37
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x006\x00\x00\x01\x00\xff\x03\xfe\xff\xff\x87\xfe\xff\xff\a"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst37
			}
			goto inst19_fail
		}
	}
	goto inst19_fail
	goto unreachable
	goto inst19_fail
inst19_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 38:
			goto inst38_alt
		}
	}
	goto fail

	goto unreachable
	goto inst34
inst34: // alt -> 23, 152
	{
		idx := i*45 + 7
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 34, 0})
	goto inst23
inst34_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst152
	}
	goto unreachable

	goto unreachable
	goto inst23
inst23: // rune "\t\n\f\r  09AZ__az" -> 33
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x006\x00\x00\x01\x00\xff\x03\xfe\xff\xff\x87\xfe\xff\xff\a"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst33
			}
			goto inst23_fail
		}
	}
	goto inst23_fail
	goto unreachable
	goto inst23_fail
inst23_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 34:
			goto inst34_alt
		}
	}
	goto fail

	goto unreachable
	goto inst16
inst16: // rune "\t\n\f\r  09AZ__az" -> 40
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x006\x00\x00\x01\x00\xff\x03\xfe\xff\xff\x87\xfe\xff\xff\a"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst40
			}
			goto inst16_fail
		}
	}
	goto inst16_fail
	goto unreachable
	goto inst16_fail
inst16_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 41:
			goto inst41_alt
		}
	}
	goto fail

	goto unreachable
	goto inst25
inst25: // rune "\t\n\f\r  09AZ__az" -> 31
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x006\x00\x00\x01\x00\xff\x03\xfe\xff\xff\x87\xfe\xff\xff\a"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst31
			}
			goto inst25_fail
		}
	}
	goto inst25_fail
	goto unreachable
	goto inst25_fail
inst25_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 32:
			goto inst32_alt
		}
	}
	goto fail

	goto unreachable
	goto inst32
inst32: // alt -> 25, 152
	{
		idx := i*45 + 8
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 32, 0})
	goto inst25
inst32_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst152
	}
	goto unreachable

	goto unreachable
	goto inst31
inst31: // alt -> 26, 152
	{
		idx := i*45 + 9
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 31, 0})
	goto inst26
inst31_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst152
	}
	goto unreachable

	goto unreachable
	goto inst26
inst26: // rune "\t\n\f\r  09AZ__az" -> 30
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x006\x00\x00\x01\x00\xff\x03\xfe\xff\xff\x87\xfe\xff\xff\a"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst30
			}
			goto inst26_fail
		}
	}
	goto inst26_fail
	goto unreachable
	goto inst26_fail
inst26_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 31:
			goto inst31_alt
		}
	}
	goto fail

	goto unreachable
	goto inst24
inst24: // rune "\t\n\f\r  09AZ__az" -> 32
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x006\x00\x00\x01\x00\xff\x03\xfe\xff\xff\x87\xfe\xff\xff\a"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst32
			}
			goto inst24_fail
		}
	}
	goto inst24_fail
	goto unreachable
	goto inst24_fail
inst24_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 33:
			goto inst33_alt
		}
	}
	goto fail

	goto unreachable
	goto inst33
inst33: // alt -> 24, 152
	{
		idx := i*45 + 10
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 33, 0})
	goto inst24
inst33_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst152
	}
	goto unreachable

	goto unreachable
	goto inst30
inst30: // alt -> 27, 152
	{
		idx := i*45 + 11
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 30, 0})
	goto inst27
inst30_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst152
	}
	goto unreachable

	goto unreachable
	goto inst27
inst27: // rune "\t\n\f\r  09AZ__az" -> 29
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x006\x00\x00\x01\x00\xff\x03\xfe\xff\xff\x87\xfe\xff\xff\a"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst29
			}
			goto inst27_fail
		}
	}
	goto inst27_fail
	goto unreachable
	goto inst27_fail
inst27_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 30:
			goto inst30_alt
		}
	}
	goto fail

	goto unreachable
	goto inst38
inst38: // alt -> 19, 152
	{
		idx := i*45 + 12
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 38, 0})
	goto inst19
inst38_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst152
	}
	goto unreachable

	goto unreachable
	goto inst18
inst18: // rune "\t\n\f\r  09AZ__az" -> 38
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x006\x00\x00\x01\x00\xff\x03\xfe\xff\xff\x87\xfe\xff\xff\a"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst38
			}
			goto inst18_fail
		}
	}
	goto inst18_fail
	goto unreachable
	goto inst18_fail
inst18_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 39:
			goto inst39_alt
		}
	}
	goto fail

	goto unreachable
	goto inst39
inst39: // alt -> 18, 152
	{
		idx := i*45 + 13
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 39, 0})
	goto inst18
inst39_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst152
	}
	goto unreachable

	goto unreachable
	goto inst29
inst29: // alt -> 28, 152
	{
		idx := i*45 + 14
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 29, 0})
	goto inst28
inst29_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst152
	}
	goto unreachable

	goto unreachable
	goto inst28
inst28: // rune "\t\n\f\r  09AZ__az" -> 152
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x006\x00\x00\x01\x00\xff\x03\xfe\xff\xff\x87\xfe\xff\xff\a"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst152
			}
			goto inst28_fail
		}
	}
	goto inst28_fail
	goto unreachable
	goto inst28_fail
inst28_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 29:
			goto inst29_alt
		}
	}
	goto fail

	goto unreachable
	goto inst41
inst41: // alt -> 16, 152
	{
		idx := i*45 + 15
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 41, 0})
	goto inst16
inst41_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst152
	}
	goto unreachable

	goto unreachable
	goto inst15
inst15: // rune "\t\n\f\r  09AZ__az" -> 41
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x006\x00\x00\x01\x00\xff\x03\xfe\xff\xff\x87\xfe\xff\xff\a"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst41
			}
			goto inst15_fail
		}
	}
	goto inst15_fail
	goto unreachable
	goto inst15_fail
inst15_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 42:
			goto inst42_alt
		}
	}
	goto fail

	goto unreachable
	goto inst42
inst42: // alt -> 15, 152
	{
		idx := i*45 + 16
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 42, 0})
	goto inst15
inst42_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst152
	}
	goto unreachable

	goto unreachable
	goto inst152
inst152: // alt -> 138, 139
	{
		idx := i*45 + 17
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 152, 0})
	goto inst138
inst152_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst139
	}
	goto unreachable

	goto unreachable
	goto inst47
inst47: // alt -> 10, 152
	{
		idx := i*45 + 18
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 47, 0})
	goto inst10
inst47_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst152
	}
	goto unreachable

	goto unreachable
	goto inst10
inst10: // rune "\t\n\f\r  09AZ__az" -> 46
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x006\x00\x00\x01\x00\xff\x03\xfe\xff\xff\x87\xfe\xff\xff\a"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst46
			}
			goto inst10_fail
		}
	}
	goto inst10_fail
	goto unreachable
	goto inst10_fail
inst10_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 47:
			goto inst47_alt
		}
	}
	goto fail

	goto unreachable
	goto inst46
inst46: // alt -> 11, 152
	{
		idx := i*45 + 19
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 46, 0})
	goto inst11
inst46_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst152
	}
	goto unreachable

	// inst53 unreacheable

	goto unreachable
	goto inst14
inst14: // rune "\t\n\f\r  09AZ__az" -> 42
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x006\x00\x00\x01\x00\xff\x03\xfe\xff\xff\x87\xfe\xff\xff\a"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst42
			}
			goto inst14_fail
		}
	}
	goto inst14_fail
	goto unreachable
	goto inst14_fail
inst14_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 43:
			goto inst43_alt
		}
	}
	goto fail

	goto unreachable
	goto inst43
inst43: // alt -> 14, 152
	{
		idx := i*45 + 20
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 43, 0})
	goto inst14
inst43_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst152
	}
	goto unreachable

	goto unreachable
	goto inst11
inst11: // rune "\t\n\f\r  09AZ__az" -> 45
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x006\x00\x00\x01\x00\xff\x03\xfe\xff\xff\x87\xfe\xff\xff\a"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst45
			}
			goto inst11_fail
		}
	}
	goto inst11_fail
	goto unreachable
	goto inst11_fail
inst11_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 46:
			goto inst46_alt
		}
	}
	goto fail

	goto unreachable
	goto inst45
inst45: // alt -> 12, 152
	{
		idx := i*45 + 21
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 45, 0})
	goto inst12
inst45_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst152
	}
	goto unreachable

	goto unreachable
	goto inst13
inst13: // rune "\t\n\f\r  09AZ__az" -> 43
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x006\x00\x00\x01\x00\xff\x03\xfe\xff\xff\x87\xfe\xff\xff\a"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst43
			}
			goto inst13_fail
		}
	}
	goto inst13_fail
	goto unreachable
	goto inst13_fail
inst13_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 44:
			goto inst44_alt
		}
	}
	goto fail

	goto unreachable
	goto inst44
inst44: // alt -> 13, 152
	{
		idx := i*45 + 22
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 44, 0})
	goto inst13
inst44_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst152
	}
	goto unreachable

	goto unreachable
	goto inst12
inst12: // rune "\t\n\f\r  09AZ__az" -> 44
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x006\x00\x00\x01\x00\xff\x03\xfe\xff\xff\x87\xfe\xff\xff\a"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst44
			}
			goto inst12_fail
		}
	}
	goto inst12_fail
	goto unreachable
	goto inst12_fail
inst12_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 45:
			goto inst45_alt
		}
	}
	goto fail

	// inst52 unreacheable

	// inst101 unreacheable

	// inst57 unreacheable

	// inst78 unreacheable

	// inst58 unreacheable

	// inst88 unreacheable

	// inst110 unreacheable

	// inst67 unreacheable

	goto unreachable
	goto inst48
inst48: // string "st" -> 55
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 2 && rs[:2] == "st" {
			i += 2
			goto inst55
		}
	}
	goto inst48_fail
	goto unreachable
	goto inst48_fail
inst48_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 64:
			goto inst64_alt
		}
	}
	goto fail

	goto unreachable
	goto inst64
inst64: // alt -> 48, 56
	{
		idx := i*45 + 23
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 64, 0})
	goto inst48
inst64_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst56
	}
	goto unreachable

	goto unreachable
	goto inst56
inst56: // string "ave" -> 63
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 3 && rs[:3] == "ave" {
			i += 3
			goto inst63
		}
	}
	goto inst56_fail
	goto unreachable
	goto inst56_fail
inst56_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 71:
			goto inst71_alt
		}
	}
	goto fail

	goto unreachable
	goto inst63
inst63: // alt -> 59, 62
	{
		idx := i*45 + 24
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 63, 0})
	goto inst59
inst63_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst62
	}
	goto unreachable

	goto unreachable
	goto inst59
inst59: // string "nue" -> 154
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 3 && rs[:3] == "nue" {
			i += 3
			goto inst154
		}
	}
	goto inst59_fail
	goto unreachable
	goto inst59_fail
inst59_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 63:
			goto inst63_alt
		}
	}
	goto fail

	goto unreachable
	goto inst71
inst71: // alt -> 64, 65
	{
		idx := i*45 + 25
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 71, 0})
	goto inst64
inst71_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst65
	}
	goto unreachable

	goto unreachable
	goto inst65
inst65: // string "r" -> 70
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 1 && rs[:1] == "r" {
			i += 1
			goto inst70
		}
	}
	goto inst65_fail
	goto unreachable
	goto inst65_fail
inst65_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 82:
			goto inst82_alt
		}
	}
	goto fail

	goto unreachable
	goto inst55
inst55: // alt -> 50, 54
	{
		idx := i*45 + 26
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 55, 0})
	goto inst50
inst55_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst54
	}
	goto unreachable

	goto unreachable
	goto inst139
inst139: // string "b" -> 151
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 1 && rs[:1] == "b" {
			i += 1
			goto inst151
		}
	}
	goto inst139_fail
	goto unreachable
	goto inst139_fail
inst139_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 5:
			goto inst5_alt
		case 6:
			goto inst6_alt
		case 7:
			goto inst7_alt
		case 29:
			goto inst29_alt
		case 30:
			goto inst30_alt
		case 31:
			goto inst31_alt
		case 32:
			goto inst32_alt
		case 33:
			goto inst33_alt
		case 34:
			goto inst34_alt
		case 35:
			goto inst35_alt
		case 36:
			goto inst36_alt
		case 37:
			goto inst37_alt
		case 38:
			goto inst38_alt
		case 39:
			goto inst39_alt
		case 40:
			goto inst40_alt
		case 41:
			goto inst41_alt
		case 42:
			goto inst42_alt
		case 43:
			goto inst43_alt
		case 44:
			goto inst44_alt
		case 45:
			goto inst45_alt
		case 46:
			goto inst46_alt
		case 47:
			goto inst47_alt
		}
	}
	goto fail

	goto unreachable
	goto inst50
inst50: // string "reet" -> 154
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 4 && rs[:4] == "reet" {
			i += 4
			goto inst154
		}
	}
	goto inst50_fail
	goto unreachable
	goto inst50_fail
inst50_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 55:
			goto inst55_alt
		}
	}
	goto fail

	// inst118 unreacheable

	goto unreachable
	goto inst70
inst70: // alt -> 66, 69
	{
		idx := i*45 + 27
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 70, 0})
	goto inst66
inst70_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst69
	}
	goto unreachable

	goto unreachable
	goto inst69
inst69: // string "d" -> 154
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 1 && rs[:1] == "d" {
			i += 1
			goto inst154
		}
	}
	goto inst69_fail
	goto unreachable
	goto inst69_fail
inst69_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 82:
			goto inst82_alt
		}
	}
	goto fail

	goto unreachable
	goto inst66
inst66: // string "oad" -> 154
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 3 && rs[:3] == "oad" {
			i += 3
			goto inst154
		}
	}
	goto inst66_fail
	goto unreachable
	goto inst66_fail
inst66_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 70:
			goto inst70_alt
		}
	}
	goto fail

	goto unreachable
	goto inst82
inst82: // alt -> 71, 72
	{
		idx := i*45 + 28
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 82, 0})
	goto inst71
inst82_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst72
	}
	goto unreachable

	goto unreachable
	goto inst72
inst72: // string "h" -> 81
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 1 && rs[:1] == "h" {
			i += 1
			goto inst81
		}
	}
	goto inst72_fail
	goto unreachable
	goto inst72_fail
inst72_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 91:
			goto inst91_alt
		}
	}
	goto fail

	// inst141 unreacheable

	// inst76 unreacheable

	// inst87 unreacheable

	// inst84 unreacheable

	goto unreachable
	goto inst151
inst151: // alt -> 140, 148
	{
		idx := i*45 + 29
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 151, 0})
	goto inst140
inst151_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst148
	}
	goto unreachable

	goto unreachable
	goto inst62
inst62: // nop -> 154
	goto inst154

	// inst68 unreacheable

	goto unreachable
	goto inst81
inst81: // alt -> 73, 79
	{
		idx := i*45 + 30
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 81, 0})
	goto inst73
inst81_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst79
	}
	goto unreachable

	goto unreachable
	goto inst73
inst73: // string "ighway" -> 154
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 6 && rs[:6] == "ighway" {
			i += 6
			goto inst154
		}
	}
	goto inst73_fail
	goto unreachable
	goto inst73_fail
inst73_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 81:
			goto inst81_alt
		}
	}
	goto fail

	goto unreachable
	goto inst91
inst91: // alt -> 82, 83
	{
		idx := i*45 + 31
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 91, 0})
	goto inst82
inst91_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst83
	}
	goto unreachable

	goto unreachable
	goto inst83
inst83: // string "sq" -> 90
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 2 && rs[:2] == "sq" {
			i += 2
			goto inst90
		}
	}
	goto inst83_fail
	goto unreachable
	goto inst83_fail
inst83_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 99:
			goto inst99_alt
		}
	}
	goto fail

	goto unreachable
	goto inst54
inst54: // nop -> 154
	goto inst154

	goto unreachable
	goto inst99
inst99: // alt -> 91, 92
	{
		idx := i*45 + 32
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 99, 0})
	goto inst91
inst99_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst92
	}
	goto unreachable

	goto unreachable
	goto inst148
inst148: // string "lvd" -> 154
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 3 && rs[:3] == "lvd" {
			i += 3
			goto inst154
		}
	}
	goto inst148_fail
	goto unreachable
	goto inst148_fail
inst148_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 5:
			goto inst5_alt
		case 6:
			goto inst6_alt
		case 7:
			goto inst7_alt
		case 29:
			goto inst29_alt
		case 30:
			goto inst30_alt
		case 31:
			goto inst31_alt
		case 32:
			goto inst32_alt
		case 33:
			goto inst33_alt
		case 34:
			goto inst34_alt
		case 35:
			goto inst35_alt
		case 36:
			goto inst36_alt
		case 37:
			goto inst37_alt
		case 38:
			goto inst38_alt
		case 39:
			goto inst39_alt
		case 40:
			goto inst40_alt
		case 41:
			goto inst41_alt
		case 42:
			goto inst42_alt
		case 43:
			goto inst43_alt
		case 44:
			goto inst44_alt
		case 45:
			goto inst45_alt
		case 46:
			goto inst46_alt
		case 47:
			goto inst47_alt
		}
	}
	goto fail

	goto unreachable
	goto inst90
inst90: // alt -> 85, 89
	{
		idx := i*45 + 33
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 90, 0})
	goto inst85
inst90_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst89
	}
	goto unreachable

	goto unreachable
	goto inst89
inst89: // nop -> 154
	goto inst154

	goto unreachable
	goto inst85
inst85: // string "uare" -> 154
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 4 && rs[:4] == "uare" {
			i += 4
			goto inst154
		}
	}
	goto inst85_fail
	goto unreachable
	goto inst85_fail
inst85_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 90:
			goto inst90_alt
		}
	}
	goto fail

	goto unreachable
	goto inst92
inst92: // string "tr" -> 98
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 2 && rs[:2] == "tr" {
			i += 2
			goto inst98
		}
	}
	goto inst92_fail
	goto unreachable
	goto inst92_fail
inst92_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 107:
			goto inst107_alt
		}
	}
	goto fail

	goto unreachable
	goto inst79
inst79: // string "wy" -> 154
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 2 && rs[:2] == "wy" {
			i += 2
			goto inst154
		}
	}
	goto inst79_fail
	goto unreachable
	goto inst79_fail
inst79_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 91:
			goto inst91_alt
		}
	}
	goto fail

	goto unreachable
	goto inst94
inst94: // string "ail" -> 154
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 3 && rs[:3] == "ail" {
			i += 3
			goto inst154
		}
	}
	goto inst94_fail
	goto unreachable
	goto inst94_fail
inst94_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 98:
			goto inst98_alt
		}
	}
	goto fail

	goto unreachable
	goto inst98
inst98: // alt -> 94, 97
	{
		idx := i*45 + 34
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 98, 0})
	goto inst94
inst98_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst97
	}
	goto unreachable

	goto unreachable
	goto inst107
inst107: // alt -> 99, 100
	{
		idx := i*45 + 35
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 107, 0})
	goto inst99
inst107_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst100
	}
	goto unreachable

	goto unreachable
	goto inst100
inst100: // string "dr" -> 106
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 2 && rs[:2] == "dr" {
			i += 2
			goto inst106
		}
	}
	goto inst100_fail
	goto unreachable
	goto inst100_fail
inst100_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 115:
			goto inst115_alt
		}
	}
	goto fail

	goto unreachable
	goto inst105
inst105: // nop -> 154
	goto inst154

	goto unreachable
	goto inst97
inst97: // string "l" -> 154
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 1 && rs[:1] == "l" {
			i += 1
			goto inst154
		}
	}
	goto inst97_fail
	goto unreachable
	goto inst97_fail
inst97_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 107:
			goto inst107_alt
		}
	}
	goto fail

	goto unreachable
	goto inst120
inst120: // nop -> 154
	goto inst154

	goto unreachable
	goto inst106
inst106: // alt -> 102, 105
	{
		idx := i*45 + 36
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 106, 0})
	goto inst102
inst106_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst105
	}
	goto unreachable

	goto unreachable
	goto inst154
inst154: // alt -> 153, 155
	{
		idx := i*45 + 37
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 154, 0})
	goto inst153
inst154_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst155
	}
	goto unreachable

	goto unreachable
	goto inst155
inst155: // match
	c[1] = i // end of match
	goto match

	goto unreachable
	goto inst102
inst102: // string "ive" -> 154
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 3 && rs[:3] == "ive" {
			i += 3
			goto inst154
		}
	}
	goto inst102_fail
	goto unreachable
	goto inst102_fail
inst102_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 106:
			goto inst106_alt
		}
	}
	goto fail

	goto unreachable
	goto inst113
inst113: // string "t" -> 154
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 1 && rs[:1] == "t" {
			i += 1
			goto inst154
		}
	}
	goto inst113_fail
	goto unreachable
	goto inst113_fail
inst113_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 129:
			goto inst129_alt
		}
	}
	goto fail

	goto unreachable
	goto inst140
inst140: // string "oulevard" -> 154
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 8 && rs[:8] == "oulevard" {
			i += 8
			goto inst154
		}
	}
	goto inst140_fail
	goto unreachable
	goto inst140_fail
inst140_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 151:
			goto inst151_alt
		}
	}
	goto fail

	goto unreachable
	goto inst114
inst114: // alt -> 109, 113
	{
		idx := i*45 + 38
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 114, 0})
	goto inst109
inst114_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst113
	}
	goto unreachable

	goto unreachable
	goto inst153
inst153: // rune "\x00/:@[^``{\U0010ffff" -> 155
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cr >= utf8.RuneSelf {
			cr, sz = utf8.DecodeRuneInString(r[i:])
		}

		if cru := uint(cr); cru < 128 {
			const runeMask = "\xff\xff\xff\xff\xff\xff\x00\xfc\x01\x00\x00x\x01\x00\x00\xf8"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst155
			}
			goto inst153_fail
		}
		if cr >= 123 && cr <= 1114111 {
			i += sz
			goto inst155
		}
	}
	goto inst153_fail
	goto unreachable
	goto inst153_fail
inst153_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 154:
			goto inst154_alt
		}
	}
	goto fail

	goto unreachable
	goto inst108
inst108: // string "c" -> 114
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 1 && rs[:1] == "c" {
			i += 1
			goto inst114
		}
	}
	goto inst108_fail
	goto unreachable
	goto inst108_fail
inst108_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 129:
			goto inst129_alt
		}
	}
	goto fail

	// inst74 unreacheable

	goto unreachable
	goto inst109
inst109: // string "ourt" -> 154
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 4 && rs[:4] == "ourt" {
			i += 4
			goto inst154
		}
	}
	goto inst109_fail
	goto unreachable
	goto inst109_fail
inst109_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 114:
			goto inst114_alt
		}
	}
	goto fail

	goto unreachable
	goto inst115
inst115: // alt -> 107, 108
	{
		idx := i*45 + 39
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 115, 0})
	goto inst107
inst115_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst108
	}
	goto unreachable

	// inst135 unreacheable

	goto unreachable
	goto inst121
inst121: // string "way" -> 154
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 3 && rs[:3] == "way" {
			i += 3
			goto inst154
		}
	}
	goto inst121_fail
	goto unreachable
	goto inst121_fail
inst121_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 128:
			goto inst128_alt
		}
	}
	goto fail

	// inst111 unreacheable

	// inst80 unreacheable

	goto unreachable
	goto inst124
inst124: // alt -> 120, 121
	{
		idx := i*45 + 40
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 124, 0})
	goto inst120
inst124_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst121
	}
	goto unreachable

	// inst142 unreacheable

	goto unreachable
	goto inst117
inst117: // string "ark" -> 124
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 3 && rs[:3] == "ark" {
			i += 3
			goto inst124
		}
	}
	goto inst117_fail
	goto unreachable
	goto inst117_fail
inst117_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 128:
			goto inst128_alt
		}
	}
	goto fail

	// inst104 unreacheable

	// inst122 unreacheable

	// inst123 unreacheable

	// inst146 unreacheable

	// inst126 unreacheable

	goto unreachable
	goto inst125
inst125: // string "kwy" -> 154
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 3 && rs[:3] == "kwy" {
			i += 3
			goto inst154
		}
	}
	goto inst125_fail
	goto unreachable
	goto inst125_fail
inst125_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 138:
			goto inst138_alt
		}
	}
	goto fail

	goto unreachable
	goto inst128
inst128: // alt -> 117, 125
	{
		idx := i*45 + 41
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 128, 0})
	goto inst117
inst128_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst125
	}
	goto unreachable

	// inst95 unreacheable

	// inst86 unreacheable

	// inst93 unreacheable

	goto unreachable
	goto inst129
inst129: // alt -> 115, 116
	{
		idx := i*45 + 42
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 129, 0})
	goto inst115
inst129_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst116
	}
	goto unreachable

	goto unreachable
	goto inst138
inst138: // alt -> 129, 130
	{
		idx := i*45 + 43
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 138, 0})
	goto inst129
inst138_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst130
	}
	goto unreachable

	goto unreachable
	goto inst116
inst116: // string "p" -> 128
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 1 && rs[:1] == "p" {
			i += 1
			goto inst128
		}
	}
	goto inst116_fail
	goto unreachable
	goto inst116_fail
inst116_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 138:
			goto inst138_alt
		}
	}
	goto fail

	// inst131 unreacheable

	// inst143 unreacheable

	// inst147 unreacheable

	goto unreachable
	goto inst130
inst130: // string "cir" -> 137
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 3 && rs[:3] == "cir" {
			i += 3
			goto inst137
		}
	}
	goto inst130_fail
	goto unreachable
	goto inst130_fail
inst130_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 152:
			goto inst152_alt
		}
	}
	goto fail

	// inst127 unreacheable

	goto unreachable
	goto inst136
inst136: // nop -> 154
	goto inst154

	goto unreachable
	goto inst133
inst133: // string "cle" -> 154
	if i >= 0 && len(r) >= i {
		if rs := r[i:]; len(rs) >= 3 && rs[:3] == "cle" {
			i += 3
			goto inst154
		}
	}
	goto inst133_fail
	goto unreachable
	goto inst133_fail
inst133_fail:
	if i <= len(r) && len(bt) > 0 {
		switch bt[len(bt)-1].pc {
		default:
			goto unreachable
		case 137:
			goto inst137_alt
		}
	}
	goto fail

	goto unreachable
	goto inst137
inst137: // alt -> 133, 136
	{
		idx := i*45 + 44
		if pi[idx/8]&(byte(1)<<(idx%8)) != 0 {
			goto fail
		}
		pi[idx/8] |= byte(1) << (idx % 8)
	}
	bt = append(bt, stateStreetAddress{c, i, 137, 0})
	goto inst133
inst137_alt:
	if len(bt) > 0 {
		n := len(bt) - 1
		c, i = bt[n].c, bt[n].i
		bt = bt[:n]
		goto inst136
	}
	goto unreachable

	// inst119 unreacheable

	// inst134 unreacheable

	// inst51 unreacheable

	// inst75 unreacheable

	// inst132 unreacheable

	// inst49 unreacheable

	// inst145 unreacheable

	// inst112 unreacheable

	// inst61 unreacheable

	// inst60 unreacheable

	// inst149 unreacheable

	// inst150 unreacheable

	// inst144 unreacheable

	// inst103 unreacheable

	// inst0 unreacheable

	// inst96 unreacheable

	// inst77 unreacheable

	goto unreachable
	goto fail
fail:
	{
		if i <= len(r) && len(bt) > 0 {
			switch bt[len(bt)-1].pc {
			default:
				panic(bt[len(bt)-1].pc)
			case 5:
				goto inst5_alt
			case 6:
				goto inst6_alt
			case 7:
				goto inst7_alt
			case 40:
				goto inst40_alt
			case 36:
				goto inst36_alt
			case 35:
				goto inst35_alt
			case 37:
				goto inst37_alt
			case 34:
				goto inst34_alt
			case 32:
				goto inst32_alt
			case 31:
				goto inst31_alt
			case 33:
				goto inst33_alt
			case 30:
				goto inst30_alt
			case 38:
				goto inst38_alt
			case 39:
				goto inst39_alt
			case 29:
				goto inst29_alt
			case 41:
				goto inst41_alt
			case 42:
				goto inst42_alt
			case 152:
				goto inst152_alt
			case 47:
				goto inst47_alt
			case 46:
				goto inst46_alt
			case 43:
				goto inst43_alt
			case 45:
				goto inst45_alt
			case 44:
				goto inst44_alt
			case 64:
				goto inst64_alt
			case 63:
				goto inst63_alt
			case 71:
				goto inst71_alt
			case 55:
				goto inst55_alt
			case 70:
				goto inst70_alt
			case 82:
				goto inst82_alt
			case 151:
				goto inst151_alt
			case 81:
				goto inst81_alt
			case 91:
				goto inst91_alt
			case 99:
				goto inst99_alt
			case 90:
				goto inst90_alt
			case 98:
				goto inst98_alt
			case 107:
				goto inst107_alt
			case 106:
				goto inst106_alt
			case 154:
				goto inst154_alt
			case 114:
				goto inst114_alt
			case 115:
				goto inst115_alt
			case 124:
				goto inst124_alt
			case 128:
				goto inst128_alt
			case 129:
				goto inst129_alt
			case 138:
				goto inst138_alt
			case 137:
				goto inst137_alt
			}
		}
		if matched {
			return bc, true
		}
		if len(r) > si {
			i = si
			cr, sz := rune(r[i]), 1
			if cr >= utf8.RuneSelf {
				cr, sz = utf8.DecodeRuneInString(r[i:])
			}

			si += sz
			_ = cr
			goto restart
		}
		return bc, false
	}

	goto unreachable
	goto match
match:
	if !matched || c[1]-c[0] > bc[1]-bc[0] {
		if m == modeMatchStreetAddress || m == modeFirstStreetAddress {
			return c, true
		}
		bc = c
		matched = true
	}
	goto fail

	goto unreachable
unreachable:
	panic("unreachable")
}
