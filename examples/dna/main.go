// File generated by regexp2go. DO NOT EDIT.
// regexp2go -flags 212 -pkg "dna" -fn "Match" "(?:(agggtaaa|tttaccct)|([cgt]gggtaaa|tttaccc[acg])|(a[act]ggtaaa|tttacc[agt]t)|(ag[act]gtaaa|tttac[agt]ct)|(agg[act]taaa|ttta[agt]cct)|(aggg[acg]aaa|ttt[cgt]ccct)|(agggt[cgt]aa|tt[acg]accct)|(agggta[cgt]a|t[acg]taccct)|(agggtaa[cgt]|[acg]ttaccct))"

package dna

import "regexp/syntax"
import "unicode/utf8"
import "strings"
import "sync"

const MatchRegexp = "(?:(agggtaaa|tttaccct)|([cgt]gggtaaa|tttaccc[acg])|(a[act]ggtaaa|tttacc[agt]t)|(ag[act]gtaaa|tttac[agt]ct)|(agg[act]taaa|ttta[agt]cct)|(aggg[acg]aaa|ttt[cgt]ccct)|(agggt[cgt]aa|tt[acg]accct)|(agggta[cgt]a|t[acg]taccct)|(agggtaa[cgt]|[acg]ttaccct))"

var _ = syntax.IsWordChar
var _ = strings.Index

type stateMatch struct {
	c   [20]int
	i   int
	pc  int
	cnt int
}

// Match implements the regular expression
// (?:(agggtaaa|tttaccct)|([cgt]gggtaaa|tttaccc[acg])|(a[act]ggtaaa|tttacc[agt]t)|(ag[act]gtaaa|tttac[agt]ct)|(agg[act]taaa|ttta[agt]cct)|(aggg[acg]aaa|ttt[cgt]ccct)|(agggt[cgt]aa|tt[acg]accct)|(agggta[cgt]a|t[acg]taccct)|(agggtaa[cgt]|[acg]ttaccct))
// with flags 212
func Match(r string) (matches [10]string, pos int, ok bool) {
	si := 0 // starting byte index
	var st stackMatch
	{
		seg := getMatch()
		st.first, st.last = seg, seg
	}
	defer st.drain()
restart:
	var c [20]int    // captures
	var bc [20]int   // captures for the longest match so far
	matched := false // succesful match flag
	i := si          // current byte index
	c[0] = i         // start of match
	goto inst179     // initial instruction

	// inst0 unreacheable

	goto unreachable
	goto inst1
inst1: // cap 2 -> 18
	c[2] = i
	goto inst18

	goto unreachable
	goto inst2
inst2: //
	if i >= 0 && i+8 <= len(r) {
		if r[i:i+8] == "agggtaaa" {
			i += 8
			goto inst19
		}
	}
	goto fail

	// inst3 unreacheable

	// inst4 unreacheable

	// inst5 unreacheable

	// inst6 unreacheable

	// inst7 unreacheable

	// inst8 unreacheable

	// inst9 unreacheable

	goto unreachable
	goto inst10
inst10: //
	if i >= 0 && i+8 <= len(r) {
		if r[i:i+8] == "tttaccct" {
			i += 8
			goto inst19
		}
	}
	goto fail

	// inst11 unreacheable

	// inst12 unreacheable

	// inst13 unreacheable

	// inst14 unreacheable

	// inst15 unreacheable

	// inst16 unreacheable

	// inst17 unreacheable

	goto unreachable
	goto inst18
inst18: // alt -> 2, 10
	st.push()
	st.last.state[st.last.len] = stateMatch{c, i, 18, 0}
	st.last.len++
	goto inst2
inst18_alt:
	{
		s, _ := st.pop()
		c, i = s.c, s.i
		goto inst10
	}

	goto unreachable
	goto inst19
inst19: // cap 3 -> 180
	c[3] = i
	goto inst180

	goto unreachable
	goto inst20
inst20: // cap 4 -> 37
	c[4] = i
	goto inst37

	goto unreachable
	goto inst21
inst21: // rune "ccggtt" -> 22
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x88\x00\x10\x00"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst22
			}
			goto fail
		} else if false {
			i += sz
			goto inst22
		}
	}
	goto fail

	goto unreachable
	goto inst22
inst22: //
	if i >= 0 && i+7 <= len(r) {
		if r[i:i+7] == "gggtaaa" {
			i += 7
			goto inst38
		}
	}
	goto fail

	// inst23 unreacheable

	// inst24 unreacheable

	// inst25 unreacheable

	// inst26 unreacheable

	// inst27 unreacheable

	// inst28 unreacheable

	goto unreachable
	goto inst29
inst29: //
	if i >= 0 && i+7 <= len(r) {
		if r[i:i+7] == "tttaccc" {
			i += 7
			goto inst36
		}
	}
	goto fail

	// inst30 unreacheable

	// inst31 unreacheable

	// inst32 unreacheable

	// inst33 unreacheable

	// inst34 unreacheable

	// inst35 unreacheable

	goto unreachable
	goto inst36
inst36: // rune "aaccgg" -> 38
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8a\x00\x00\x00"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst38
			}
			goto fail
		} else if false {
			i += sz
			goto inst38
		}
	}
	goto fail

	goto unreachable
	goto inst37
inst37: // alt -> 21, 29
	st.push()
	st.last.state[st.last.len] = stateMatch{c, i, 37, 0}
	st.last.len++
	goto inst21
inst37_alt:
	{
		s, _ := st.pop()
		c, i = s.c, s.i
		goto inst29
	}

	goto unreachable
	goto inst38
inst38: // cap 5 -> 180
	c[5] = i
	goto inst180

	goto unreachable
	goto inst39
inst39: // alt -> 1, 20
	st.push()
	st.last.state[st.last.len] = stateMatch{c, i, 39, 0}
	st.last.len++
	goto inst1
inst39_alt:
	{
		s, _ := st.pop()
		c, i = s.c, s.i
		goto inst20
	}

	goto unreachable
	goto inst40
inst40: // cap 6 -> 57
	c[6] = i
	goto inst57

	goto unreachable
	goto inst41
inst41: //
	if i >= 0 && i+1 <= len(r) {
		if r[i:i+1] == "a" {
			i += 1
			goto inst42
		}
	}
	goto fail

	goto unreachable
	goto inst42
inst42: // rune "aacctt" -> 43
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\n\x00\x10\x00"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst43
			}
			goto fail
		} else if false {
			i += sz
			goto inst43
		}
	}
	goto fail

	goto unreachable
	goto inst43
inst43: //
	if i >= 0 && i+6 <= len(r) {
		if r[i:i+6] == "ggtaaa" {
			i += 6
			goto inst58
		}
	}
	goto fail

	// inst44 unreacheable

	// inst45 unreacheable

	// inst46 unreacheable

	// inst47 unreacheable

	// inst48 unreacheable

	goto unreachable
	goto inst49
inst49: //
	if i >= 0 && i+6 <= len(r) {
		if r[i:i+6] == "tttacc" {
			i += 6
			goto inst55
		}
	}
	goto fail

	// inst50 unreacheable

	// inst51 unreacheable

	// inst52 unreacheable

	// inst53 unreacheable

	// inst54 unreacheable

	goto unreachable
	goto inst55
inst55: // rune "aaggtt" -> 56
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x82\x00\x10\x00"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst56
			}
			goto fail
		} else if false {
			i += sz
			goto inst56
		}
	}
	goto fail

	goto unreachable
	goto inst56
inst56: //
	if i >= 0 && i+1 <= len(r) {
		if r[i:i+1] == "t" {
			i += 1
			goto inst58
		}
	}
	goto fail

	goto unreachable
	goto inst57
inst57: // alt -> 41, 49
	st.push()
	st.last.state[st.last.len] = stateMatch{c, i, 57, 0}
	st.last.len++
	goto inst41
inst57_alt:
	{
		s, _ := st.pop()
		c, i = s.c, s.i
		goto inst49
	}

	goto unreachable
	goto inst58
inst58: // cap 7 -> 180
	c[7] = i
	goto inst180

	goto unreachable
	goto inst59
inst59: // alt -> 39, 40
	st.push()
	st.last.state[st.last.len] = stateMatch{c, i, 59, 0}
	st.last.len++
	goto inst39
inst59_alt:
	{
		s, _ := st.pop()
		c, i = s.c, s.i
		goto inst40
	}

	goto unreachable
	goto inst60
inst60: // cap 8 -> 77
	c[8] = i
	goto inst77

	goto unreachable
	goto inst61
inst61: //
	if i >= 0 && i+2 <= len(r) {
		if r[i:i+2] == "ag" {
			i += 2
			goto inst63
		}
	}
	goto fail

	// inst62 unreacheable

	goto unreachable
	goto inst63
inst63: // rune "aacctt" -> 64
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\n\x00\x10\x00"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst64
			}
			goto fail
		} else if false {
			i += sz
			goto inst64
		}
	}
	goto fail

	goto unreachable
	goto inst64
inst64: //
	if i >= 0 && i+5 <= len(r) {
		if r[i:i+5] == "gtaaa" {
			i += 5
			goto inst78
		}
	}
	goto fail

	// inst65 unreacheable

	// inst66 unreacheable

	// inst67 unreacheable

	// inst68 unreacheable

	goto unreachable
	goto inst69
inst69: //
	if i >= 0 && i+5 <= len(r) {
		if r[i:i+5] == "tttac" {
			i += 5
			goto inst74
		}
	}
	goto fail

	// inst70 unreacheable

	// inst71 unreacheable

	// inst72 unreacheable

	// inst73 unreacheable

	goto unreachable
	goto inst74
inst74: // rune "aaggtt" -> 75
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x82\x00\x10\x00"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst75
			}
			goto fail
		} else if false {
			i += sz
			goto inst75
		}
	}
	goto fail

	goto unreachable
	goto inst75
inst75: //
	if i >= 0 && i+2 <= len(r) {
		if r[i:i+2] == "ct" {
			i += 2
			goto inst78
		}
	}
	goto fail

	// inst76 unreacheable

	goto unreachable
	goto inst77
inst77: // alt -> 61, 69
	st.push()
	st.last.state[st.last.len] = stateMatch{c, i, 77, 0}
	st.last.len++
	goto inst61
inst77_alt:
	{
		s, _ := st.pop()
		c, i = s.c, s.i
		goto inst69
	}

	goto unreachable
	goto inst78
inst78: // cap 9 -> 180
	c[9] = i
	goto inst180

	goto unreachable
	goto inst79
inst79: // alt -> 59, 60
	st.push()
	st.last.state[st.last.len] = stateMatch{c, i, 79, 0}
	st.last.len++
	goto inst59
inst79_alt:
	{
		s, _ := st.pop()
		c, i = s.c, s.i
		goto inst60
	}

	goto unreachable
	goto inst80
inst80: // cap 10 -> 97
	c[10] = i
	goto inst97

	goto unreachable
	goto inst81
inst81: //
	if i >= 0 && i+3 <= len(r) {
		if r[i:i+3] == "agg" {
			i += 3
			goto inst84
		}
	}
	goto fail

	// inst82 unreacheable

	// inst83 unreacheable

	goto unreachable
	goto inst84
inst84: // rune "aacctt" -> 85
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\n\x00\x10\x00"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst85
			}
			goto fail
		} else if false {
			i += sz
			goto inst85
		}
	}
	goto fail

	goto unreachable
	goto inst85
inst85: //
	if i >= 0 && i+4 <= len(r) {
		if r[i:i+4] == "taaa" {
			i += 4
			goto inst98
		}
	}
	goto fail

	// inst86 unreacheable

	// inst87 unreacheable

	// inst88 unreacheable

	goto unreachable
	goto inst89
inst89: //
	if i >= 0 && i+4 <= len(r) {
		if r[i:i+4] == "ttta" {
			i += 4
			goto inst93
		}
	}
	goto fail

	// inst90 unreacheable

	// inst91 unreacheable

	// inst92 unreacheable

	goto unreachable
	goto inst93
inst93: // rune "aaggtt" -> 94
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x82\x00\x10\x00"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst94
			}
			goto fail
		} else if false {
			i += sz
			goto inst94
		}
	}
	goto fail

	goto unreachable
	goto inst94
inst94: //
	if i >= 0 && i+3 <= len(r) {
		if r[i:i+3] == "cct" {
			i += 3
			goto inst98
		}
	}
	goto fail

	// inst95 unreacheable

	// inst96 unreacheable

	goto unreachable
	goto inst97
inst97: // alt -> 81, 89
	st.push()
	st.last.state[st.last.len] = stateMatch{c, i, 97, 0}
	st.last.len++
	goto inst81
inst97_alt:
	{
		s, _ := st.pop()
		c, i = s.c, s.i
		goto inst89
	}

	goto unreachable
	goto inst98
inst98: // cap 11 -> 180
	c[11] = i
	goto inst180

	goto unreachable
	goto inst99
inst99: // alt -> 79, 80
	st.push()
	st.last.state[st.last.len] = stateMatch{c, i, 99, 0}
	st.last.len++
	goto inst79
inst99_alt:
	{
		s, _ := st.pop()
		c, i = s.c, s.i
		goto inst80
	}

	goto unreachable
	goto inst100
inst100: // cap 12 -> 117
	c[12] = i
	goto inst117

	goto unreachable
	goto inst101
inst101: //
	if i >= 0 && i+4 <= len(r) {
		if r[i:i+4] == "aggg" {
			i += 4
			goto inst105
		}
	}
	goto fail

	// inst102 unreacheable

	// inst103 unreacheable

	// inst104 unreacheable

	goto unreachable
	goto inst105
inst105: // rune "aaccgg" -> 106
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8a\x00\x00\x00"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst106
			}
			goto fail
		} else if false {
			i += sz
			goto inst106
		}
	}
	goto fail

	goto unreachable
	goto inst106
inst106: //
	if i >= 0 && i+3 <= len(r) {
		if r[i:i+3] == "aaa" {
			i += 3
			goto inst118
		}
	}
	goto fail

	// inst107 unreacheable

	// inst108 unreacheable

	goto unreachable
	goto inst109
inst109: //
	if i >= 0 && i+3 <= len(r) {
		if r[i:i+3] == "ttt" {
			i += 3
			goto inst112
		}
	}
	goto fail

	// inst110 unreacheable

	// inst111 unreacheable

	goto unreachable
	goto inst112
inst112: // rune "ccggtt" -> 113
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x88\x00\x10\x00"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst113
			}
			goto fail
		} else if false {
			i += sz
			goto inst113
		}
	}
	goto fail

	goto unreachable
	goto inst113
inst113: //
	if i >= 0 && i+4 <= len(r) {
		if r[i:i+4] == "ccct" {
			i += 4
			goto inst118
		}
	}
	goto fail

	// inst114 unreacheable

	// inst115 unreacheable

	// inst116 unreacheable

	goto unreachable
	goto inst117
inst117: // alt -> 101, 109
	st.push()
	st.last.state[st.last.len] = stateMatch{c, i, 117, 0}
	st.last.len++
	goto inst101
inst117_alt:
	{
		s, _ := st.pop()
		c, i = s.c, s.i
		goto inst109
	}

	goto unreachable
	goto inst118
inst118: // cap 13 -> 180
	c[13] = i
	goto inst180

	goto unreachable
	goto inst119
inst119: // alt -> 99, 100
	st.push()
	st.last.state[st.last.len] = stateMatch{c, i, 119, 0}
	st.last.len++
	goto inst99
inst119_alt:
	{
		s, _ := st.pop()
		c, i = s.c, s.i
		goto inst100
	}

	goto unreachable
	goto inst120
inst120: // cap 14 -> 137
	c[14] = i
	goto inst137

	goto unreachable
	goto inst121
inst121: //
	if i >= 0 && i+5 <= len(r) {
		if r[i:i+5] == "agggt" {
			i += 5
			goto inst126
		}
	}
	goto fail

	// inst122 unreacheable

	// inst123 unreacheable

	// inst124 unreacheable

	// inst125 unreacheable

	goto unreachable
	goto inst126
inst126: // rune "ccggtt" -> 127
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x88\x00\x10\x00"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst127
			}
			goto fail
		} else if false {
			i += sz
			goto inst127
		}
	}
	goto fail

	goto unreachable
	goto inst127
inst127: //
	if i >= 0 && i+2 <= len(r) {
		if r[i:i+2] == "aa" {
			i += 2
			goto inst138
		}
	}
	goto fail

	// inst128 unreacheable

	goto unreachable
	goto inst129
inst129: //
	if i >= 0 && i+2 <= len(r) {
		if r[i:i+2] == "tt" {
			i += 2
			goto inst131
		}
	}
	goto fail

	// inst130 unreacheable

	goto unreachable
	goto inst131
inst131: // rune "aaccgg" -> 132
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8a\x00\x00\x00"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst132
			}
			goto fail
		} else if false {
			i += sz
			goto inst132
		}
	}
	goto fail

	goto unreachable
	goto inst132
inst132: //
	if i >= 0 && i+5 <= len(r) {
		if r[i:i+5] == "accct" {
			i += 5
			goto inst138
		}
	}
	goto fail

	// inst133 unreacheable

	// inst134 unreacheable

	// inst135 unreacheable

	// inst136 unreacheable

	goto unreachable
	goto inst137
inst137: // alt -> 121, 129
	st.push()
	st.last.state[st.last.len] = stateMatch{c, i, 137, 0}
	st.last.len++
	goto inst121
inst137_alt:
	{
		s, _ := st.pop()
		c, i = s.c, s.i
		goto inst129
	}

	goto unreachable
	goto inst138
inst138: // cap 15 -> 180
	c[15] = i
	goto inst180

	goto unreachable
	goto inst139
inst139: // alt -> 119, 120
	st.push()
	st.last.state[st.last.len] = stateMatch{c, i, 139, 0}
	st.last.len++
	goto inst119
inst139_alt:
	{
		s, _ := st.pop()
		c, i = s.c, s.i
		goto inst120
	}

	goto unreachable
	goto inst140
inst140: // cap 16 -> 157
	c[16] = i
	goto inst157

	goto unreachable
	goto inst141
inst141: //
	if i >= 0 && i+6 <= len(r) {
		if r[i:i+6] == "agggta" {
			i += 6
			goto inst147
		}
	}
	goto fail

	// inst142 unreacheable

	// inst143 unreacheable

	// inst144 unreacheable

	// inst145 unreacheable

	// inst146 unreacheable

	goto unreachable
	goto inst147
inst147: // rune "ccggtt" -> 148
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x88\x00\x10\x00"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst148
			}
			goto fail
		} else if false {
			i += sz
			goto inst148
		}
	}
	goto fail

	goto unreachable
	goto inst148
inst148: //
	if i >= 0 && i+1 <= len(r) {
		if r[i:i+1] == "a" {
			i += 1
			goto inst158
		}
	}
	goto fail

	goto unreachable
	goto inst149
inst149: //
	if i >= 0 && i+1 <= len(r) {
		if r[i:i+1] == "t" {
			i += 1
			goto inst150
		}
	}
	goto fail

	goto unreachable
	goto inst150
inst150: // rune "aaccgg" -> 151
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8a\x00\x00\x00"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst151
			}
			goto fail
		} else if false {
			i += sz
			goto inst151
		}
	}
	goto fail

	goto unreachable
	goto inst151
inst151: //
	if i >= 0 && i+6 <= len(r) {
		if r[i:i+6] == "taccct" {
			i += 6
			goto inst158
		}
	}
	goto fail

	// inst152 unreacheable

	// inst153 unreacheable

	// inst154 unreacheable

	// inst155 unreacheable

	// inst156 unreacheable

	goto unreachable
	goto inst157
inst157: // alt -> 141, 149
	st.push()
	st.last.state[st.last.len] = stateMatch{c, i, 157, 0}
	st.last.len++
	goto inst141
inst157_alt:
	{
		s, _ := st.pop()
		c, i = s.c, s.i
		goto inst149
	}

	goto unreachable
	goto inst158
inst158: // cap 17 -> 180
	c[17] = i
	goto inst180

	goto unreachable
	goto inst159
inst159: // alt -> 139, 140
	st.push()
	st.last.state[st.last.len] = stateMatch{c, i, 159, 0}
	st.last.len++
	goto inst139
inst159_alt:
	{
		s, _ := st.pop()
		c, i = s.c, s.i
		goto inst140
	}

	goto unreachable
	goto inst160
inst160: // cap 18 -> 177
	c[18] = i
	goto inst177

	goto unreachable
	goto inst161
inst161: //
	if i >= 0 && i+7 <= len(r) {
		if r[i:i+7] == "agggtaa" {
			i += 7
			goto inst168
		}
	}
	goto fail

	// inst162 unreacheable

	// inst163 unreacheable

	// inst164 unreacheable

	// inst165 unreacheable

	// inst166 unreacheable

	// inst167 unreacheable

	goto unreachable
	goto inst168
inst168: // rune "ccggtt" -> 178
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x88\x00\x10\x00"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst178
			}
			goto fail
		} else if false {
			i += sz
			goto inst178
		}
	}
	goto fail

	goto unreachable
	goto inst169
inst169: // rune "aaccgg" -> 170
	if i >= 0 && i < len(r) {
		cr, sz := rune(r[i]), 1
		if cru := uint(cr); cru < 128 {
			const runeMask = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8a\x00\x00\x00"
			if runeMask[cru/8]&(1<<(cru%8)) != 0 {
				i += sz
				goto inst170
			}
			goto fail
		} else if false {
			i += sz
			goto inst170
		}
	}
	goto fail

	goto unreachable
	goto inst170
inst170: //
	if i >= 0 && i+7 <= len(r) {
		if r[i:i+7] == "ttaccct" {
			i += 7
			goto inst178
		}
	}
	goto fail

	// inst171 unreacheable

	// inst172 unreacheable

	// inst173 unreacheable

	// inst174 unreacheable

	// inst175 unreacheable

	// inst176 unreacheable

	goto unreachable
	goto inst177
inst177: // alt -> 161, 169
	st.push()
	st.last.state[st.last.len] = stateMatch{c, i, 177, 0}
	st.last.len++
	goto inst161
inst177_alt:
	{
		s, _ := st.pop()
		c, i = s.c, s.i
		goto inst169
	}

	goto unreachable
	goto inst178
inst178: // cap 19 -> 180
	c[19] = i
	goto inst180

	goto unreachable
	goto inst179
inst179: // alt -> 159, 160
	st.push()
	st.last.state[st.last.len] = stateMatch{c, i, 179, 0}
	st.last.len++
	goto inst159
inst179_alt:
	{
		s, _ := st.pop()
		c, i = s.c, s.i
		goto inst160
	}

	goto unreachable
	goto inst180
inst180: // match
	c[1] = i // end of match
	goto match

	goto unreachable
	goto fail
fail:
	{
		if ps, ok := st.peek(); i <= len(r) && ok {
			switch ps.pc {
			default:
				panic(ps.pc)
			case 18:
				goto inst18_alt
			case 37:
				goto inst37_alt
			case 39:
				goto inst39_alt
			case 57:
				goto inst57_alt
			case 59:
				goto inst59_alt
			case 77:
				goto inst77_alt
			case 79:
				goto inst79_alt
			case 97:
				goto inst97_alt
			case 99:
				goto inst99_alt
			case 117:
				goto inst117_alt
			case 119:
				goto inst119_alt
			case 137:
				goto inst137_alt
			case 139:
				goto inst139_alt
			case 157:
				goto inst157_alt
			case 159:
				goto inst159_alt
			case 177:
				goto inst177_alt
			case 179:
				goto inst179_alt
			}
		}
		if matched {
			var m [10]string
			m[0] = r[bc[0]:bc[1]]
			m[1] = r[bc[2]:bc[3]]
			m[2] = r[bc[4]:bc[5]]
			m[3] = r[bc[6]:bc[7]]
			m[4] = r[bc[8]:bc[9]]
			m[5] = r[bc[10]:bc[11]]
			m[6] = r[bc[12]:bc[13]]
			m[7] = r[bc[14]:bc[15]]
			m[8] = r[bc[16]:bc[17]]
			m[9] = r[bc[18]:bc[19]]
			return m, si, true
		}
		if len(r[si:]) != 0 {
			i = si
			cr, sz := rune(r[i]), 1
			if cr >= utf8.RuneSelf {
				cr, sz = utf8.DecodeRuneInString(r[i:])
			}

			si += sz
			_ = cr
			st.reset()
			goto restart
		}
		var m [10]string
		return m, len(r), false
	}

	goto unreachable
	goto match
match:
	if !matched || c[1]-c[0] > bc[1]-bc[0] {
		bc = c
		matched = true
	}
	goto fail

	goto unreachable
unreachable:
	panic("unreachable")
}

var poolMatch = sync.Pool{New: func() interface{} { return &segmentMatch{} }}

type segmentMatch struct {
	state [256]stateMatch // states
	len   uint16          // how many elements of state are populated
	next  *segmentMatch   // next segment
	prev  *segmentMatch   // previous segment
}

func getMatch() *segmentMatch {
	return poolMatch.Get().(*segmentMatch)
}

func putMatch(s *segmentMatch) {
	s.next, s.prev, s.len = nil, nil, 0
	poolMatch.Put(s)
}

type stackMatch struct {
	// first segment in the stack; this is just used to simplify drain()
	first *segmentMatch
	// currently active segment: this is the segment where push/peek/pop operate;
	// note that additional empty segments may be already be allocated and linked
	// after the last segment
	last *segmentMatch
}

func (st *stackMatch) push() {
	if int(st.last.len) == cap(st.last.state) {
		st.pushSlow()
	}
}

func (st *stackMatch) pushSlow() {
	if st.last.next != nil {
		st.last = st.last.next
	} else {
		seg := getMatch()
		st.last.next = seg
		seg.prev = st.last
		st.last = seg
	}
}

func (st *stackMatch) peek() (*stateMatch, bool) {
	if st.last.len > 0 {
		return &st.last.state[st.last.len-1], true
	}
	return st.peekSlow()
}

func (st *stackMatch) peekSlow() (*stateMatch, bool) {
	if st.last.prev != nil {
		st.last = st.last.prev
	} else {
		return nil, false
	}
	return &st.last.state[st.last.len-1], true
}

func (st *stackMatch) pop() (*stateMatch, bool) {
	sp, ok := st.peek()
	if ok {
		st.last.len--
	}
	return sp, ok
}

// drain puts all stack segments back into the segment pool
func (st *stackMatch) drain() {
	seg := st.first
	for seg != nil {
		next := seg.next
		putMatch(seg)
		seg = next
	}
	st.first, st.last = nil, nil
}

// reset resets the stack without returning the segments to the segment pool
func (st *stackMatch) reset() {
	seg := st.first
	for seg != nil {
		next := seg.next
		if seg.len == 0 {
			return
		}
		seg.len = 0
		seg = next
	}
}
